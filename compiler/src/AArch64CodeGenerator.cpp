#include "R-Sharp/AArch64CodeGenerator.hpp"
#include "R-Sharp/Logging.hpp"
#include "R-Sharp/AstNodes.hpp"
#include "R-Sharp/Utils.hpp"

#include <sstream>

AArch64CodeGenerator::AArch64CodeGenerator(std::shared_ptr<AstProgram> root, std::string R_SharpSource){
    this->root = root;
    this->R_SharpSource = R_SharpSource;
}

void AArch64CodeGenerator::indent(){
    indentLevel++;
}
void AArch64CodeGenerator::dedent(){
    if (!indentLevel){
        Fatal("Indentation error");
        return;
    }
    indentLevel--;
}
void AArch64CodeGenerator::emit(std::string const& str, AArch64CodeGenerator::BinarySection section){
    switch (section){
        case AArch64CodeGenerator::BinarySection::Text:
            source_text += str;
            break;
        case AArch64CodeGenerator::BinarySection::BSS:
            source_bss += str;
            break;
        case AArch64CodeGenerator::BinarySection::Data:
            source_data += str;
            break;
    }
}
void AArch64CodeGenerator::emitIndented(std::string const& str, AArch64CodeGenerator::BinarySection section){
    for (int i=0;i<indentLevel;i++){
        source_text += "    ";
    }
    switch (section){
        case AArch64CodeGenerator::BinarySection::Text:
            source_text += str;
            break;
        case AArch64CodeGenerator::BinarySection::BSS:
            source_bss += str;
            break;
        case AArch64CodeGenerator::BinarySection::Data:
            source_data += str;
            break;
    }
}

std::string AArch64CodeGenerator::generate(){
    source_text = "";
    source_data = "";
    source_bss = "";
    indentLevel = 0;
    root->accept(this);

    std::string output = "";
    output += "// AArch64 code generated by R-Sharp compiler\n\n";
    output += "// Macros for readability\n";
    output += ".macro push reg\n"
              " str \\reg, [sp, -16]!\n"
              ".endm\n"
              ".macro pop reg\n"
              " ldr \\reg, [sp], 16\n"
              ".endm\n\n";
    output += ".text\n";
    output += source_text;
    output += "\n.data\n";
    output += source_data;
    output += "\n.bss\n";
    output += source_bss;


    return output;
}

std::string AArch64CodeGenerator::getUniqueLabel(std::string const& prefix){
    static uint64_t labelCounter = 0;
    return prefix + "_" + std::to_string(labelCounter++);
}

void AArch64CodeGenerator::generateFunctionProlouge(){
    emitIndented("// Create stack frame\n");

    // TODO: save callee-saved registers
    emitIndented("mov fp, sp\n");

    stackOffset = 0;
}
void AArch64CodeGenerator::generateFunctionEpilouge(){
    emitIndented("// Destroy stack frame\n");
    
    // TODO: restore callee-saved registers
}
void AArch64CodeGenerator::resetStackPointer(std::shared_ptr<AstBlock> scope){
    emitIndented("// Restore stack pointer to before this scope (" + scope->name + ")\n");
    emitIndented("add sp, sp, " + std::to_string(scope->sizeOfLocalVariables) + "\n");
}

// program
void AArch64CodeGenerator::visit(std::shared_ptr<AstProgram> node){
    node->globalScope->accept(this);

    for (auto const& child : node->getChildren()){
        if (!child) continue;
        if (child->getType() == AstNodeType::AstFunctionDeclaration){
            child->accept(this);
        }
        else if (child->getType() == AstNodeType::AstVariableDeclaration){
            child->accept(this);
        }
        else{
            Fatal("Invalid node type in program");
        }
    }

    // emit extern functions
    for (auto func : node->items){
        if (func->getType() == AstNodeType::AstFunctionDeclaration){
            if (!std::dynamic_pointer_cast<AstFunctionDeclaration>(func)->function->isDefined)
                emitIndented(".extern " + std::dynamic_pointer_cast<AstFunctionDeclaration>(func)->function->accessString + "\n");
        }
    }

    // uninitialized global variables
    for (auto var : root->uninitializedGlobalVariables){
        if (!var->isDefined){
            emit(var->accessStr + ":\n", BinarySection::BSS);
            emit("    .space ", BinarySection::BSS);
            emit(std::to_string(var->sizeInBytes) + "\n", BinarySection::BSS);
        }
    }
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstParameterList> node){
    // generate access strings
    node->parameterBlock->accept(this);

    int argumentNumber = 0;
    for (auto const& child : node->parameters){
        if (argumentNumber == 0) emitIndented("mov x9, x0\n");
        child->accept(this);
        if (argumentNumber == 0) emitIndented("mov x0, x9\n");

        emitIndented("// Store argument " + std::to_string(argumentNumber) + " on stack\n");
        emitIndented("str x" + std::to_string(argumentNumber) + ", " + child->variable->accessStr + "\n");

        argumentNumber++;
    }
}

// definitions
void AArch64CodeGenerator::visit(std::shared_ptr<AstFunctionDeclaration> node){

    if (node->body){
        emitIndented("// Function " + node->name + "\n\n");
        emitIndented(".global " + node->name + "\n");
        emitIndented(node->name + ":\n");
        indent();
        generateFunctionProlouge();

        node->parameters->accept(this);
        node->body->accept(this);

        emitIndented("// fallback if the function has no return\n");
        generateFunctionEpilouge();
        emitIndented("mov x0, 0\n");
        emitIndented("ret\n");
        dedent();
    }
}


// statements
void AArch64CodeGenerator::visit(std::shared_ptr<AstBlock> node){
    emitIndented("// Block begin (" + node->name + ")\n");
    indent();
    
    int scopeSize = 0;
    for (auto var : node->variables){
        if (var->isGlobal){
            var->accessStr = getUniqueLabel(var->name);
        }
        else{
            stackOffset += var->sizeInBytes;
            scopeSize += var->sizeInBytes;
            var->accessStr = "[fp, -" + std::to_string(stackOffset) +"]";
        }
    }

    for (auto child : node->getChildren()){
        if (child) child->accept(this);
    }

    // don't change stack pointer if it wasn't modified
    if (scopeSize) stackOffset -= scopeSize;
    if (!node->isMerged) resetStackPointer(node);
    dedent();
    emitIndented("// Block end (" + node->name + ")\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstReturn> node){
    node->value->accept(this);
    for (auto scope = node->containedScopes.rbegin(); scope != node->containedScopes.rend(); ++scope){
        if (scope->expired()){
            Fatal("INTERNAL ERROR: std::weak_ptr expired during code generation.");
        }
        else{
            resetStackPointer(scope->lock());
        }
    }
    generateFunctionEpilouge();
    emitIndented("ret\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstConditionalStatement> node){
    std::string else_label = getUniqueLabel("else");
    std::string end_label = getUniqueLabel("end");

    node->condition->accept(this);
    emitIndented("// If statement\n");
    emitIndented("cbz x0, " + else_label + "\n");
    indent();
    node->trueStatement->accept(this);
    emitIndented("b " + end_label + "\n");
    dedent();
    emitIndented(else_label + ":\n");
    indent();
    if (node->falseStatement) node->falseStatement->accept(this);
    dedent();
    emitIndented(end_label + ":\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstForLoopDeclaration> node){
    std::string start_label = getUniqueLabel("start");
    std::string end_label = getUniqueLabel("end");
    std::string increment_label = getUniqueLabel("increment");

    node->loop->skipAccessString = increment_label;
    node->loop->breakAccessString = end_label;
    
    // manually generate the access string for the counter variable
    stackOffset += node->initialization->variable->sizeInBytes;
    node->initialization->variable->accessStr = "[fp, -" + std::to_string(stackOffset) +"]";


    emitIndented("// For loop\n");
    emitIndented("// For loop initialization\n");
    node->initialization->accept(this);

    emitIndented("// For loop\n");
    emitIndented(start_label + ":\n");
    indent();
    emitIndented("// For loop condition\n");
    node->condition->accept(this);
    emitIndented("cbz x0, " + end_label + "\n");
    emitIndented("// For loop body\n");
    node->body->accept(this);
    dedent();
    emitIndented("// For loop increment\n");
    emitIndented(increment_label + ":\n");
    indent();
    node->increment->accept(this);
    emitIndented("b " + start_label + "\n");
    dedent();
    emitIndented(end_label + ":\n");

    // manually restore the stack pointer
    resetStackPointer(node->initializationContext);
    emitIndented("// For loop end\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstForLoopExpression> node){
    std::string start_label = getUniqueLabel("start");
    std::string end_label = getUniqueLabel("end");
    std::string increment_label = getUniqueLabel("increment");

    node->loop->skipAccessString = increment_label;
    node->loop->breakAccessString = end_label;

    emitIndented("// For loop\n");
    emitIndented("// For loop initialization\n");
    node->variable->accept(this);

    emitIndented("// For loop\n");
    emitIndented(start_label + ":\n");
    indent();
    emitIndented("// For loop condition\n");
    node->condition->accept(this);
    emitIndented("cbz x0, " + end_label + "\n");

    emitIndented("// For loop body\n");
    node->body->accept(this);
    dedent();
    emitIndented("// For loop increment\n");
    emitIndented(increment_label + ":\n");
    indent();
    node->increment->accept(this);
    emitIndented("b " + start_label + "\n");

    dedent();
    emitIndented(end_label + ":\n");
    emitIndented("// For loop end\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstWhileLoop> node){
    std::string start_label = getUniqueLabel("start");
    std::string end_label = getUniqueLabel("end");

    node->loop->skipAccessString = start_label;
    node->loop->breakAccessString = end_label;

    emitIndented("// While loop\n");
    emitIndented(start_label + ":\n");
    indent();
    node->condition->accept(this);
    emitIndented("cbz x0, " + end_label + "\n");
    emitIndented("// Body\n");
    node->body->accept(this);
    emitIndented("b " + start_label + "\n");
    dedent();
    emitIndented(end_label + ":\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstDoWhileLoop> node){
    std::string start_label = getUniqueLabel("start");
    std::string end_label = getUniqueLabel("end");

    node->loop->skipAccessString = start_label;
    node->loop->breakAccessString = end_label;

    emitIndented("// Do loop\n");
    emitIndented(start_label + ":\n");
    indent();
    emitIndented("// Body\n");
    node->body->accept(this);
    node->condition->accept(this);
    emitIndented("cbnz x0, " + start_label + "\n");
    dedent();
    emitIndented(end_label + ":\n");

}
void AArch64CodeGenerator::visit(std::shared_ptr<AstBreak> node){
    for (auto varScope = node->containedScopes.rbegin(); varScope != node->containedScopes.rend(); ++varScope){
        if (varScope->expired()){
            Fatal("INTERNAL ERROR: std::weak_ptr expired during code generation.");
        }
        else{
            resetStackPointer(varScope->lock());
        }
    }

    emitIndented("// Break\n");
    emitIndented("b " + node->loop->breakAccessString + "\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstSkip> node){
    for (auto varScope = node->containedScopes.rbegin(); varScope != node->containedScopes.rend(); ++varScope){
        if (varScope->expired()){
            Fatal("INTERNAL ERROR: std::weak_ptr expired during code generation.");
        }
        else{
            resetStackPointer(varScope->lock());
        }
    }

    emitIndented("// Skip\n");
    emitIndented("b " + node->loop->skipAccessString + "\n");
}


// expressions
void AArch64CodeGenerator::visit(std::shared_ptr<AstUnary> node){
    node->value->accept(this);
    switch (node->type){
        case AstUnaryType::Negate:
            emitIndented("neg x0, x0\n");
            break;
        case AstUnaryType::BinaryNot:
            emitIndented("mvn x0, x0\n");
            break;
        case AstUnaryType::LogicalNot:
            emitIndented("cmp x0, 0\n");
            emitIndented("cset x0, eq\n");
            break;
        default:
            Error("AArch64 Generator: Unary operator not implemented!");
            printErrorToken(node->token, R_SharpSource);
            exit(1);
            break;
    }
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstBinary> node){
    node->left->accept(this);

    // logical and and or will short circuit, so the right side is not evaluated until necessary
    if (!(node->type == AstBinaryType::LogicalOr || node->type == AstBinaryType::LogicalAnd)){
        emitIndented("push x0\n");
        node->right->accept(this);
        emitIndented("mov x1, x0\n");
        emitIndented("pop x0\n");
    }
    switch (node->type){
        case AstBinaryType::Add:
            emitIndented("// Add\n");
            emitIndented("add x0, x0, x1\n");
            break;
        case AstBinaryType::Subtract:
            emitIndented("// Subtract\n");
            emitIndented("sub x0, x0, x1\n");
            break;
        case AstBinaryType::Multiply:
            emitIndented("// Multiply\n");
            emitIndented("mul x0, x0, x1\n");
            break;
        case AstBinaryType::Divide:
            emitIndented("// Divide\n");
            emitIndented("sdiv x0, x0, x1\n");
            break;
        case AstBinaryType::Modulo:
            emitIndented("// Modulo\n");
            emitIndented("sdiv x2, x0, x1\n");
            emitIndented("msub x0, x2, x1, x0\n");
            break;

        case AstBinaryType::Equal:
            emitIndented("// Equal\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, eq\n");
            break;
        case AstBinaryType::NotEqual:
            emitIndented("// Not Equal\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, ne\n");
            break;
        case AstBinaryType::LessThan:
            emitIndented("// Less Than\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, lt\n");
            break;
        case AstBinaryType::LessThanOrEqual:
            emitIndented("// Less Than Or Equal\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, le\n");
            break;
        case AstBinaryType::GreaterThan:
            emitIndented("// Greater Than\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, gt\n");
            break;
        case AstBinaryType::GreaterThanOrEqual:
            emitIndented("// Greater Than Or Equal\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, ge\n");
            break;

        case AstBinaryType::LogicalAnd:{
            emitIndented("// Logical And\n");
            std::string end = getUniqueLabel("end");
            emitIndented("cbz x0, " + end + "\n");

            // evaluate right side
            node->right->accept(this);
            emitIndented("cmp x0, 0\n");
            emitIndented("cset x0, ne\n");
            emitIndented(end + ":\n");
            break;
        }

        case AstBinaryType::LogicalOr:{
            emitIndented("// Logical Or\n");
            std::string clause2 = getUniqueLabel("second_expression");
            std::string end = getUniqueLabel("end");
            emitIndented("cbz x0, " + clause2 + "\n");
            emitIndented("mov x0, 1\n");
            emitIndented("b " + end + "\n");
            emitIndented(clause2 + ":\n"); indent();

            // evaluate right side
            node->right->accept(this);
            emitIndented("cmp x0, 0\n");
            emitIndented("cset x0, ne\n");
            dedent();
            emitIndented(end + ":\n");
            break;
        }
        default:
            Error("AArch64 Generator: Binary operator not implemented!");
            printErrorToken(node->token, R_SharpSource);
            exit(1);
            break;
    }
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstInteger> node){
    emitIndented("// Integer " + std::to_string(node->value) + "\n");
    emitIndented("mov x0, " + std::to_string(node->value) + "\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstVariableAccess> node){
    emitIndented("// Variable Access(" + node->name + ")\n");
    if (node->variable->isGlobal){
        emitIndented("ldr x9, =[" + node->variable->accessStr + "]\n");
        emitIndented("ldr x0, [x9]\n");
    }
    else
        emitIndented("ldr x0, " + node->variable->accessStr + "\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstVariableAssignment> node){
    node->value->accept(this);
    if (node->variable->isGlobal){
        emitIndented("ldr x9, =[" + node->variable->accessStr + "]\n");
        emitIndented("str x0, [x9]\n");
    }
    else{
        emitIndented("str x0, " + node->variable->accessStr + "\n");
    }
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstConditionalExpression> node){
    std::string true_clause = getUniqueLabel("true_expression");
    std::string false_clause = getUniqueLabel("false_expression");
    std::string end = getUniqueLabel("end");
    node->condition->accept(this);
    emitIndented("// Conditional Expression\n");
    emitIndented("cbz x0, " + false_clause + "\n");
    emitIndented(true_clause + ":\n"); indent();
    node->trueExpression->accept(this);
    emitIndented("b " + end + "\n");
    dedent();
    emitIndented(false_clause + ":\n"); indent();
    node->falseExpression->accept(this);
    dedent();
    emitIndented(end + ":\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstEmptyExpression> node){
    emitIndented("// Empty Expression\n");
    emitIndented("mov x0, 1\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstFunctionCall> node){
    // rdi, rsi, rdx, rcx, r8, and r9 are used for parameters
    // more than 6 parameters are not supported yet

    if (node->arguments.size() > 6){
        Error("AArch64 Generator: More than 6 parameters are not supported yet!");
        printErrorToken(node->token, R_SharpSource);
        exit(1);
    }
    // save registers

    // evaluate arguments
    for (auto arg : node->arguments){
        arg->accept(this);
        emitIndented("push x0\n");
    }
    // move arguments to registers
    if (node->arguments.size() > 8){
        Error("AArch64 Generator: More than 8 function arguments aren't yet supported!");
        printErrorToken(node->arguments.at(8)->token, R_SharpSource);
        exit(1);
    }
    for (int i=node->arguments.size()-1; i>=0; i--){
        emitIndented("pop x" + std::to_string(i) + "\n");
    }

    emitIndented("// Prepare for function call (" + node->name + ")\n");
    emitIndented("stp x29, x30, [sp, -16]!\n");
    emitIndented("mov x29, sp\n");
    emitIndented("// Function Call (" + node->name + ")\n");
    emitIndented("bl " + node->name + "\n");

    emitIndented("// Restore after function call (" + node->name + ")\n");
    emitIndented("ldp x29, x30, [sp], 16\n");
}


// declarations
void AArch64CodeGenerator::visit(std::shared_ptr<AstVariableDeclaration> node){
    if (node->variable->isGlobal){
        if (!node->value){
            return;
        }
        if (node->value->getType() != AstNodeType::AstInteger){
            Error("AArch64 Generator: Global variable must be of type integer!");
            printErrorToken(node->token, R_SharpSource);
            exit(1);
        }
        auto intNode = std::dynamic_pointer_cast<AstInteger>(node->value);
        emit("    // Global Variable (" + node->name + ")\n", BinarySection::Data);
        

        emit("    .global " + node->variable->accessStr + "\n", BinarySection::Data);
        emit(node->variable->accessStr + ":\n", BinarySection::Data);
        switch(node->variable->sizeInBytes){
            case 1: emit("    .byte " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            case 2: emit("    .2byte " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            case 4: emit("    .4byte " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            case 8: emit("    .8byte " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            default:
                Error("AArch64 Generator: Global variable size not supported!");
                printErrorToken(node->token, R_SharpSource);
                exit(1);
                break;
        }
    }
    else{
        emitIndented("// Variable (" + node->name + ")\n");
        if (node->value){
            node->value->accept(this);
            emitIndented("str x0, [sp, -" + std::to_string(node->variable->sizeInBytes) + "]!\n");
        }
        else{
            emitIndented("mov x0, 0\n");
            emitIndented("str x0, [sp, -" + std::to_string(node->variable->sizeInBytes) + "]!\n");
        }
    }
}