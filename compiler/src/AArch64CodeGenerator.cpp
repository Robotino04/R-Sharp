#include "R-Sharp/AArch64CodeGenerator.hpp"
#include "R-Sharp/Logging.hpp"
#include "R-Sharp/AstNodes.hpp"
#include "R-Sharp/Utils.hpp"
#include "R-Sharp/VariableSizeInserter.hpp"

#include <sstream>
#include <map>

AArch64CodeGenerator::AArch64CodeGenerator(std::shared_ptr<AstProgram> root, std::string R_SharpSource){
    this->root = root;
    this->R_SharpSource = R_SharpSource;
}

void AArch64CodeGenerator::indent(){
    indentLevel++;
}
void AArch64CodeGenerator::dedent(){
    if (!indentLevel){
        Fatal("Indentation error");
        return;
    }
    indentLevel--;
}
void AArch64CodeGenerator::emit(std::string const& str, AArch64CodeGenerator::BinarySection section){
    switch (section){
        case AArch64CodeGenerator::BinarySection::Text:
            source_text += str;
            break;
        case AArch64CodeGenerator::BinarySection::BSS:
            source_bss += str;
            break;
        case AArch64CodeGenerator::BinarySection::Data:
            source_data += str;
            break;
    }
}
void AArch64CodeGenerator::emitIndented(std::string const& str, AArch64CodeGenerator::BinarySection section){
    for (int i=0;i<indentLevel;i++){
        source_text += "    ";
    }
    switch (section){
        case AArch64CodeGenerator::BinarySection::Text:
            source_text += str;
            break;
        case AArch64CodeGenerator::BinarySection::BSS:
            source_bss += str;
            break;
        case AArch64CodeGenerator::BinarySection::Data:
            source_data += str;
            break;
    }
}


int AArch64CodeGenerator::sizeFromSemanticalType(std::shared_ptr<AstType> type){
    static const std::map<RSharpPrimitiveType, int> primitive_sizes = {
        {RSharpPrimitiveType::I8, 1},
        {RSharpPrimitiveType::I16, 2},
        {RSharpPrimitiveType::I32, 4},
        {RSharpPrimitiveType::I64, 8},
    };

    switch(type->getType()){
        case AstNodeType::AstPrimitiveType:{
            return primitive_sizes.at(std::static_pointer_cast<AstPrimitiveType>(type)->type);
        }
        case AstNodeType::AstPointerType:{
            return 8;
        }
        default: throw std::runtime_error("Unimplemented type used");
    }
}

std::string AArch64CodeGenerator::generate(){
    source_text = "";
    source_data = "";
    source_bss = "";
    indentLevel = 0;

    VariableSizeInserter sizeInserter(root);
    sizeInserter.insert(AArch64CodeGenerator::sizeFromSemanticalType);

    root->accept(this);

    std::string output = "";
    output += "// AArch64 code generated by R-Sharp compiler\n\n";
    output += "// Macros for readability\n";
    output += ".macro push reg\n"
              " str \\reg, [sp, -16]!\n"
              ".endm\n"
              ".macro pop reg\n"
              " ldr \\reg, [sp], 16\n"
              ".endm\n\n";
    output += ".text\n";
    output += source_text;
    output += "\n.data\n";
    output += source_data;
    output += "\n.bss\n";
    output += source_bss;


    return output;
}

std::string AArch64CodeGenerator::getUniqueLabel(std::string const& prefix){
    static uint64_t labelCounter = 0;
    return prefix + "_" + std::to_string(labelCounter++);
}

void AArch64CodeGenerator::generateFunctionProlouge(){
    emitIndented("// Create stack frame\n");

    // TODO: save callee-saved registers
    emitIndented("mov fp, sp\n");
}
void AArch64CodeGenerator::generateFunctionEpilouge(){
    emitIndented("// Destroy stack frame\n");
    
    // TODO: restore callee-saved registers
}
void AArch64CodeGenerator::resetStackPointer(std::shared_ptr<AstBlock> scope){
    emitIndented("// Restore stack pointer to before this scope (" + scope->name + ")\n");
    emitIndented("add sp, sp, " + std::to_string(scope->sizeOfLocalVariables) + "\n");
}

// program
void AArch64CodeGenerator::visit(std::shared_ptr<AstProgram> node){
    node->globalScope->accept(this);
    
    for (auto var : node->globalScope->variables){
        var->accessor = getUniqueLabel(var->name);
    }

    for (auto const& child : node->getChildren()){
        if (!child) continue;
        if (child->getType() == AstNodeType::AstFunctionDefinition){
            child->accept(this);
        }
        else if (child->getType() == AstNodeType::AstVariableDeclaration){
            child->accept(this);
        }
        else{
            Fatal("Invalid node type in program");
        }
    }


    // uninitialized global variables
    for (auto var : root->uninitializedGlobalVariables){
        if (!var->isDefined){
            emit(std::get<std::string>(var->accessor) + ":\n", BinarySection::BSS);
            emit("    .space ", BinarySection::BSS);
            emit(std::to_string(var->sizeInBytes) + "\n", BinarySection::BSS);
        }
    }
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstParameterList> node){
    // generate access strings
    node->parameterBlock->accept(this);

    int argumentNumber = 0;
    for (auto const& child : node->parameters){
        if (argumentNumber == 0) emitIndented("mov x9, x0\n");
        child->accept(this);
        if (argumentNumber == 0) emitIndented("mov x0, x9\n");

        emitIndented("// Store argument " + std::to_string(argumentNumber) + " on stack\n");
        emitIndented("str x" + std::to_string(argumentNumber) + ", [fp, -" + std::to_string(std::get<int>(child->variable->accessor)) + "]\n");

        argumentNumber++;
    }
}

// definitions
void AArch64CodeGenerator::visit(std::shared_ptr<AstFunctionDefinition> node){
    if(std::find(node->tags->tags.begin(), node->tags->tags.end(), AstTags::Value::Extern) == node->tags->tags.end()){
        emitIndented("// Function " + node->name + "\n\n");
        emitIndented(".global " + node->functionData->name + "\n");
        emitIndented(node->functionData->name + ":\n");
        indent();
        generateFunctionProlouge();

        node->parameters->accept(this);
        node->body->accept(this);

        emitIndented("// fallback if the function has no return\n");
        generateFunctionEpilouge();
        emitIndented("mov x0, 0\n");
        emitIndented("ret\n");
        dedent();
    }
    else{
        emitIndented(".extern " + node->functionData->name + "\n");
    }
}


// statements
void AArch64CodeGenerator::visit(std::shared_ptr<AstBlock> node){
    emitIndented("// Block begin (" + node->name + ")\n");
    indent();

    for (auto child : node->getChildren()){
        if (child) child->accept(this);
    }

    // don't change stack pointer if it wasn't modified
    if (!node->isMerged) resetStackPointer(node);
    dedent();
    emitIndented("// Block end (" + node->name + ")\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstReturn> node){
    node->value->accept(this);
    for (auto scope = node->containedScopes.rbegin(); scope != node->containedScopes.rend(); ++scope){
        if (scope->expired()){
            Fatal("INTERNAL ERROR: std::weak_ptr expired during code generation.");
        }
        else{
            resetStackPointer(scope->lock());
        }
    }
    generateFunctionEpilouge();
    emitIndented("ret\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstConditionalStatement> node){
    std::string else_label = "." + getUniqueLabel("else");
    std::string end_label = "." + getUniqueLabel("end");

    node->condition->accept(this);
    emitIndented("// If statement\n");
    emitIndented("cbz x0, " + else_label + "\n");
    indent();
    node->trueStatement->accept(this);
    emitIndented("b " + end_label + "\n");
    dedent();
    emitIndented(else_label + ":\n");
    indent();
    if (node->falseStatement) node->falseStatement->accept(this);
    dedent();
    emitIndented(end_label + ":\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstForLoopDeclaration> node){
    std::string start_label = "." + getUniqueLabel("start");
    std::string end_label = "." + getUniqueLabel("end");
    std::string increment_label = getUniqueLabel("increment");

    node->loop->skipAccessString = increment_label;
    node->loop->breakAccessString = end_label;

    emitIndented("// For loop\n");
    emitIndented("// For loop initialization\n");
    node->initialization->accept(this);

    emitIndented("// For loop\n");
    emitIndented(start_label + ":\n");
    indent();
    emitIndented("// For loop condition\n");
    node->condition->accept(this);
    emitIndented("cbz x0, " + end_label + "\n");
    emitIndented("// For loop body\n");
    node->body->accept(this);
    dedent();
    emitIndented("// For loop increment\n");
    emitIndented(increment_label + ":\n");
    indent();
    node->increment->accept(this);
    emitIndented("b " + start_label + "\n");
    dedent();
    emitIndented(end_label + ":\n");

    // manually restore the stack pointer
    resetStackPointer(node->initializationContext);
    emitIndented("// For loop end\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstForLoopExpression> node){
    std::string start_label = "." + getUniqueLabel("start");
    std::string end_label = "." + getUniqueLabel("end");
    std::string increment_label = "." + getUniqueLabel("increment");

    node->loop->skipAccessString = increment_label;
    node->loop->breakAccessString = end_label;

    emitIndented("// For loop\n");
    emitIndented("// For loop initialization\n");
    node->variable->accept(this);

    emitIndented("// For loop\n");
    emitIndented(start_label + ":\n");
    indent();
    emitIndented("// For loop condition\n");
    node->condition->accept(this);
    emitIndented("cbz x0, " + end_label + "\n");

    emitIndented("// For loop body\n");
    node->body->accept(this);
    dedent();
    emitIndented("// For loop increment\n");
    emitIndented(increment_label + ":\n");
    indent();
    node->increment->accept(this);
    emitIndented("b " + start_label + "\n");

    dedent();
    emitIndented(end_label + ":\n");
    emitIndented("// For loop end\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstWhileLoop> node){
    std::string start_label = "." + getUniqueLabel("start");
    std::string end_label = "." + getUniqueLabel("end");

    node->loop->skipAccessString = start_label;
    node->loop->breakAccessString = end_label;

    emitIndented("// While loop\n");
    emitIndented(start_label + ":\n");
    indent();
    node->condition->accept(this);
    emitIndented("cbz x0, " + end_label + "\n");
    emitIndented("// Body\n");
    node->body->accept(this);
    emitIndented("b " + start_label + "\n");
    dedent();
    emitIndented(end_label + ":\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstDoWhileLoop> node){
    std::string start_label = "." + getUniqueLabel("start");
    std::string end_label = "." + getUniqueLabel("end");

    node->loop->skipAccessString = start_label;
    node->loop->breakAccessString = end_label;

    emitIndented("// Do loop\n");
    emitIndented(start_label + ":\n");
    indent();
    emitIndented("// Body\n");
    node->body->accept(this);
    node->condition->accept(this);
    emitIndented("cbnz x0, " + start_label + "\n");
    dedent();
    emitIndented(end_label + ":\n");

}
void AArch64CodeGenerator::visit(std::shared_ptr<AstBreak> node){
    for (auto varScope = node->containedScopes.rbegin(); varScope != node->containedScopes.rend(); ++varScope){
        if (varScope->expired()){
            Fatal("INTERNAL ERROR: std::weak_ptr expired during code generation.");
        }
        else{
            resetStackPointer(varScope->lock());
        }
    }

    emitIndented("// Break\n");
    emitIndented("b " + node->loop->breakAccessString + "\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstSkip> node){
    for (auto varScope = node->containedScopes.rbegin(); varScope != node->containedScopes.rend(); ++varScope){
        if (varScope->expired()){
            Fatal("INTERNAL ERROR: std::weak_ptr expired during code generation.");
        }
        else{
            resetStackPointer(varScope->lock());
        }
    }

    emitIndented("// Skip\n");
    emitIndented("b " + node->loop->skipAccessString + "\n");
}


// expressions
void AArch64CodeGenerator::visit(std::shared_ptr<AstUnary> node){
    node->value->accept(this);
    switch (node->type){
        case AstUnaryType::Negate:
            emitIndented("neg x0, x0\n");
            break;
        case AstUnaryType::BinaryNot:
            emitIndented("mvn x0, x0\n");
            break;
        case AstUnaryType::LogicalNot:
            emitIndented("cmp x0, 0\n");
            emitIndented("cset x0, eq\n");
            break;
        default:
            Error("AArch64 Generator: Unary operator not implemented!");
            printErrorToken(node->token, R_SharpSource);
            exit(1);
            break;
    }
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstBinary> node){
    node->left->accept(this);

    // logical and and or will short circuit, so the right side is not evaluated until necessary
    if (!(node->type == AstBinaryType::LogicalOr || node->type == AstBinaryType::LogicalAnd)){
        emitIndented("push x0\n");
        node->right->accept(this);
        emitIndented("mov x1, x0\n");
        emitIndented("pop x0\n");
    }
    switch (node->type){
        case AstBinaryType::Add:
            emitIndented("// Add\n");
            if (node->left->semanticType->getType() == AstNodeType::AstPointerType){
                emitIndented("mov x2, " + std::to_string(sizeFromSemanticalType(node->left->semanticType)) + "\n");
                // x0 = x0 + (x1 * x2)
                emitIndented("madd x0, x1, x2, x0\n");
            }
            else if (node->right->semanticType->getType() == AstNodeType::AstPointerType){
                emitIndented("mov x2, " + std::to_string(sizeFromSemanticalType(node->left->semanticType)) + "\n");
                // x0 = x1 + (x0 * x2)
                emitIndented("madd x0, x0, x2, x1\n");
            }
            else{
                emitIndented("add x0, x0, x1\n");
            }
            break;
        case AstBinaryType::Subtract:
            emitIndented("// Subtract\n");
            if (node->left->semanticType->getType() == AstNodeType::AstPointerType){
                emitIndented("mov x2, " + std::to_string(sizeFromSemanticalType(node->left->semanticType)) + "\n");
                // x0 = x0 - (x1 * x2)
                emitIndented("msub x0, x1, x2, x0\n");
            }
            else if (node->right->semanticType->getType() == AstNodeType::AstPointerType){
                emitIndented("mov x2, " + std::to_string(sizeFromSemanticalType(node->left->semanticType)) + "\n");
                // x0 = x1 - (x0 * x2)
                emitIndented("msub x0, x0, x2, x1\n");
            }
            else{
                emitIndented("sub x0, x0, x1\n");
            }
            break;
        case AstBinaryType::Multiply:
            emitIndented("// Multiply\n");
            emitIndented("mul x0, x0, x1\n");
            break;
        case AstBinaryType::Divide:
            emitIndented("// Divide\n");
            if (sizeFromSemanticalType(node->left->semanticType) == 1)
                emitIndented("sxtb w0, w0    // sign extend from 8-bit to 16-bit\n");
            if (sizeFromSemanticalType(node->left->semanticType) <= 2)
                emitIndented("sxth w0, w0    // sign extend from 16-bit to 32-bit\n");

            
            if (sizeFromSemanticalType(node->right->semanticType) == 1)
                emitIndented("sxtb w1, w1    // sign extend from 8-bit to 16-bit\n");
            if (sizeFromSemanticalType(node->right->semanticType) <= 2)
                emitIndented("sxth w1, w1    // sign extend from 16-bit to 32-bit\n");

            if (sizeFromSemanticalType(node->left->semanticType) == 8)
                emitIndented("sdiv x0, x0, x1\n");
            else
                emitIndented("sdiv w0, w0, w1\n");

            break;
        case AstBinaryType::Modulo:
            emitIndented("// Modulo\n");
            emitIndented("sdiv x2, x0, x1\n");
            emitIndented("msub x0, x2, x1, x0\n");
            break;

        case AstBinaryType::Equal:
            emitIndented("// Equal\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, eq\n");
            break;
        case AstBinaryType::NotEqual:
            emitIndented("// Not Equal\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, ne\n");
            break;
        case AstBinaryType::LessThan:
            emitIndented("// Less Than\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, lt\n");
            break;
        case AstBinaryType::LessThanOrEqual:
            emitIndented("// Less Than Or Equal\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, le\n");
            break;
        case AstBinaryType::GreaterThan:
            emitIndented("// Greater Than\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, gt\n");
            break;
        case AstBinaryType::GreaterThanOrEqual:
            emitIndented("// Greater Than Or Equal\n");
            emitIndented("cmp x0, x1\n");
            emitIndented("cset x0, ge\n");
            break;

        case AstBinaryType::LogicalAnd:{
            emitIndented("// Logical And\n");
            std::string end = "." + getUniqueLabel("end");
            emitIndented("cbz x0, " + end + "\n");

            // evaluate right side
            node->right->accept(this);
            emitIndented("cmp x0, 0\n");
            emitIndented("cset x0, ne\n");
            emitIndented(end + ":\n");
            break;
        }

        case AstBinaryType::LogicalOr:{
            emitIndented("// Logical Or\n");
            std::string clause2 = "." + getUniqueLabel("second_expression");
            std::string end = "." + getUniqueLabel("end");
            emitIndented("cbz x0, " + clause2 + "\n");
            emitIndented("mov x0, 1\n");
            emitIndented("b " + end + "\n");
            emitIndented(clause2 + ":\n"); indent();

            // evaluate right side
            node->right->accept(this);
            emitIndented("cmp x0, 0\n");
            emitIndented("cset x0, ne\n");
            dedent();
            emitIndented(end + ":\n");
            break;
        }
        default:
            Error("AArch64 Generator: Binary operator not implemented!");
            printErrorToken(node->token, R_SharpSource);
            exit(1);
            break;
    }
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstInteger> node){
    emitIndented("// Integer " + std::to_string(node->value) + "\n");
    if (node->value == 0){
        emitIndented("mov x0, xzr\n");
        return;
    }
    // needs up to 4 instructions
    // movz MOVes and Zeros the rest
    // movk MOVes and Keeps the rest

    uint64_t valueCopy = static_cast<uint64_t>(node->value);
    for (int shiftAmount = 0; valueCopy >> shiftAmount && shiftAmount < 64; shiftAmount += 16){
        if (shiftAmount == 0){
            emitIndented("movz x0, " + std::to_string((valueCopy >> shiftAmount) & 0xFFFF) + "\n");
        }
        else{
            emitIndented("movk x0, " + std::to_string((valueCopy >> shiftAmount) & 0xFFFF) + ", lsl " + std::to_string(shiftAmount) + "\n");
        }
    }
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstVariableAccess> node){
    emitIndented("// Variable Access(" + node->name + ")\n");
    if (node->variable->isGlobal){
        emitIndented("ldr x9, =[" + std::get<std::string>(node->variable->accessor) + "]\n");
        emitIndented("ldr");
            switch(node->variable->sizeInBytes){
                case 1: emit("b w0"); break;
                case 2: emit("h w0"); break;
                case 4: emit(" w0"); break;
                case 8: emit(" x0"); break;
                default:
                    Error("AArch64 Generator: Variable size ", node->variable->sizeInBytes, " not supported!");
                    printErrorToken(node->token, R_SharpSource);
                    exit(1);
                    break;
            }
            emit(", [x9]\n");
    }
    else{
        emitIndented("ldr");
        switch(node->variable->sizeInBytes){
            case 1: emit("b w0"); break;
            case 2: emit("h w0"); break;
            case 4: emit(" w0"); break;
            case 8: emit(" x0"); break;
            default:
                Error("AArch64 Generator: Variable size ", node->variable->sizeInBytes, " not supported!");
                printErrorToken(node->token, R_SharpSource);
                exit(1);
                break;
        }
        emit(", [fp, -" + std::to_string(std::get<int>(node->variable->accessor)) + "]\n");
    }
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstAssignment> node){
    node->rvalue->accept(this);
    if (node->lvalue->getType() == AstNodeType::AstVariableAccess){
        auto var = std::static_pointer_cast<AstVariableAccess>(node->lvalue);
        if (var->variable->isGlobal){
            emitIndented("ldr x9, =[" + std::get<std::string>(var->variable->accessor) + "]\n");
            emitIndented("str");
            switch(var->variable->sizeInBytes){
                case 1: emit("b w0"); break;
                case 2: emit("h w0"); break;
                case 4: emit(" w0"); break;
                case 8: emit(" x0"); break;
                default:
                    Error("AArch64 Generator: Variable size ", var->variable->sizeInBytes, " not supported!");
                    printErrorToken(node->token, R_SharpSource);
                    exit(1);
                    break;
            }
            emit(", [x9]\n");
        }
        else{
            emitIndented("str");
            switch(var->variable->sizeInBytes){
                case 1: emit("b w0"); break;
                case 2: emit("h w0"); break;
                case 4: emit(" w0"); break;
                case 8: emit(" x0"); break;
                default:
                    Error("AArch64 Generator: Variable size ", var->variable->sizeInBytes, " not supported!");
                    printErrorToken(node->token, R_SharpSource);
                    exit(1);
                    break;
            }
            emit(", [fp, -" + std::to_string(std::get<int>(var->variable->accessor)) + "]\n");
        }
    }
    else if(node->lvalue->getType() == AstNodeType::AstDereference){
        auto deref = std::static_pointer_cast<AstDereference>(node->lvalue);
        emitIndented("// Assignment\n");
        emitIndented("push x0\n");

        // put the address to store to into x0
        deref->operand->accept(this);

        emitIndented("mov x1, x0\n");
        emitIndented("pop x0\n");

        auto size = sizeFromSemanticalType(deref->semanticType);
        switch(size){
            case 1: emitIndented("strb w0, [x1]\n"); break;
            case 2: emitIndented("strh w0, [x1]\n"); break;
            case 4: emitIndented("str w0, [x1]\n"); break;
            case 8: emitIndented("str x0, [x1]\n"); break;
            default:
                Error("AArch64 Generator: Variable size ", size, " not supported!");
                printErrorToken(deref->operand->token, R_SharpSource);
                exit(1);
                break;
        }
    }
    else{
        Error("Unimplemented type of lvalue.");
        printErrorToken(node->lvalue->token, R_SharpSource);
        exit(1);
    }
    
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstConditionalExpression> node){
    std::string true_clause = "." + getUniqueLabel("true_expression");
    std::string false_clause = "." + getUniqueLabel("false_expression");
    std::string end = "." + getUniqueLabel("end");
    node->condition->accept(this);
    emitIndented("// Conditional Expression\n");
    emitIndented("cbz x0, " + false_clause + "\n");
    emitIndented(true_clause + ":\n"); indent();
    node->trueExpression->accept(this);
    emitIndented("b " + end + "\n");
    dedent();
    emitIndented(false_clause + ":\n"); indent();
    node->falseExpression->accept(this);
    dedent();
    emitIndented(end + ":\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstEmptyExpression> node){
    emitIndented("// Empty Expression\n");
    emitIndented("mov x0, 1\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstFunctionCall> node){
    // rdi, rsi, rdx, rcx, r8, and r9 are used for parameters
    // more than 6 parameters are not supported yet

    if (node->arguments.size() > 6){
        Error("AArch64 Generator: More than 6 parameters are not supported yet!");
        printErrorToken(node->token, R_SharpSource);
        exit(1);
    }
    // save registers

    // evaluate arguments
    for (auto arg : node->arguments){
        arg->accept(this);
        emitIndented("push x0\n");
    }
    if (node->arguments.size() > 8){
        Error("AArch64 Generator: More than 8 function arguments aren't yet supported!");
        printErrorToken(node->arguments.at(8)->token, R_SharpSource);
        exit(1);
    }
    // move arguments to registers
    for (int i=node->arguments.size()-1; i>=0; i--){
        emitIndented("pop x" + std::to_string(i) + "\n");
    }

    emitIndented("// Prepare for function call (" + node->name + ")\n");
    emitIndented("stp x29, x30, [sp, -16]!\n");
    emitIndented("mov x29, sp\n");
    emitIndented("// Function Call (" + node->name + ")\n");
    emitIndented("bl " + node->function->name + "\n");

    emitIndented("// Restore after function call (" + node->name + ")\n");
    emitIndented("ldp x29, x30, [sp], 16\n");
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstAddressOf> node){
    emitIndented("// addres of (" + node->operand->name + ")\n");
    if (node->operand->variable->isGlobal){
        emitIndented("ldr x0, =" + std::get<std::string>(node->operand->variable->accessor) + "\n");
    }
    else{
        emitIndented("sub x0, fp, " + std::to_string(std::get<int>(node->operand->variable->accessor)) + "\n");
    }
}
void AArch64CodeGenerator::visit(std::shared_ptr<AstTypeConversion> node){
    int originSize = sizeFromSemanticalType(node->value->semanticType);
    int targetSize = sizeFromSemanticalType(node->semanticType);
    node->value->accept(this);
    if (targetSize > originSize){
        emitIndented("// Convert from " + std::to_string(originSize) + " bytes to " + std::to_string(targetSize) + " bytes.\n");
        emitIndented("sxt");
        switch(originSize){
            case 1: emit("b "); break;
            case 2: emit("h "); break;
            case 4: emit("w "); break;
            case 8: emit("d "); break;
            default:
                Fatal("AArch64 Generator: Converting from size ", originSize, " not supported!");
                break;
        }
        switch(targetSize){
            case 1:
            case 2:
            case 4:
                emit("w0, "); break;
            case 8:
                emit("x0, "); break;
            default:
                Fatal("AArch64 Generator: Converting to size  ", targetSize, " not supported!");
                break;
        }
        emit("w0\n");
    }
    else if (targetSize == originSize);
    else{
        emitIndented("// explicit and to detect invalid upcasts later (" + std::to_string(originSize) + " Bytes --> " + std::to_string(targetSize) + " Bytes)\n");
        emitIndented("mov x1, " + std::to_string(uint64_t((__uint128_t(1) << __uint128_t(targetSize*8))-1)) + "\n");
        emitIndented("and x0, x0, x1\n");
    }
}



// declarations
void AArch64CodeGenerator::visit(std::shared_ptr<AstVariableDeclaration> node){
    if (node->variable->isGlobal){
        if (!node->value){
            return;
        }
        if (node->value->getType() != AstNodeType::AstInteger){
            Error("AArch64 Generator: Global variable must be of type integer!");
            printErrorToken(node->token, R_SharpSource);
            exit(1);
        }
        auto intNode = std::dynamic_pointer_cast<AstInteger>(node->value);
        emit("    // Global Variable (" + node->name + ")\n", BinarySection::Data);
        

        emit("    .global " + std::get<std::string>(node->variable->accessor) + "\n", BinarySection::Data);
        emit(std::get<std::string>(node->variable->accessor) + ":\n", BinarySection::Data);
        switch(node->variable->sizeInBytes){
            case 1: emit("    .byte " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            case 2: emit("    .2byte " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            case 4: emit("    .4byte " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            case 8: emit("    .8byte " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            default:
                Error("AArch64 Generator: Global variable size not supported!");
                printErrorToken(node->token, R_SharpSource);
                exit(1);
                break;
        }
    }
    else{
        emitIndented("// Variable (" + node->name + ")\n");
        if (node->value){
            node->value->accept(this);
        }
        else{
            emitIndented("mov x0, 0\n");
        }
        switch(node->variable->sizeInBytes){
            case 1: emitIndented("strb w0, [sp, -" + std::to_string(node->variable->sizeInBytes) + "]!\n"); break;
            case 2: emitIndented("strh w0, [sp, -" + std::to_string(node->variable->sizeInBytes) + "]!\n"); break;
            case 4: emitIndented("str w0, [sp, -" + std::to_string(node->variable->sizeInBytes) + "]!\n"); break;
            case 8: emitIndented("str x0, [sp, -" + std::to_string(node->variable->sizeInBytes) + "]!\n"); break;
            default:
                Error("AArch64 Generator: Variable size ", node->variable->sizeInBytes, " not supported!");
                printErrorToken(node->token, R_SharpSource);
                exit(1);
                break;
        }
    }
}

void AArch64CodeGenerator::visit(std::shared_ptr<AstDereference> node){
    node->operand->accept(this);
    emitIndented("// Dereference\n");
    emitIndented("ldr x0, [x0]\n");
}