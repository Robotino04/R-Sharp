#include "R-Sharp/NASMCodeGenerator.hpp"
#include "R-Sharp/Logging.hpp"
#include "R-Sharp/AstNodes.hpp"
#include "R-Sharp/Utils.hpp"
#include "R-Sharp/VariableSizeInserter.hpp"

#include <sstream>
#include <map>
#include <tuple>
#include <math.h>

NASMCodeGenerator::NASMCodeGenerator(std::shared_ptr<AstProgram> root, std::string R_SharpSource){
    this->root = root;
    this->R_SharpSource = R_SharpSource;
}

void NASMCodeGenerator::indent(NASMCodeGenerator::BinarySection section){
    indentLevels.at(static_cast<int>(section))++;
}
void NASMCodeGenerator::dedent(NASMCodeGenerator::BinarySection section){
    if (!indentLevels.at(static_cast<int>(section))){
        Fatal("Indentation error in section nr. " + std::to_string(static_cast<int>(section)));
        return;
    }
    indentLevels.at(static_cast<int>(section))--;
}
void NASMCodeGenerator::emit(std::string const& str, NASMCodeGenerator::BinarySection section){
    sources.at(static_cast<int>(section)) += str;
}
void NASMCodeGenerator::emitIndented(std::string const& str, NASMCodeGenerator::BinarySection section){
    for (int i=0; i<indentLevels.at(static_cast<int>(section)); i++){
        sources.at(static_cast<int>(section)) += "    ";
    }
    sources.at(static_cast<int>(section)) += str;
}

int NASMCodeGenerator::sizeFromSemanticalType(std::shared_ptr<AstType> type){
    static const std::map<RSharpPrimitiveType, int> primitive_sizes = {
        {RSharpPrimitiveType::C_void, 1}, // should only be used for pointer arithmetic
        {RSharpPrimitiveType::I8, 1},
        {RSharpPrimitiveType::I16, 2},
        {RSharpPrimitiveType::I32, 4},
        {RSharpPrimitiveType::I64, 8},
    };

    switch(type->getType()){
        case AstNodeType::AstPrimitiveType:{
            return primitive_sizes.at(std::static_pointer_cast<AstPrimitiveType>(type)->type);
        }
        case AstNodeType::AstPointerType:{
            return 8;
        }
        case AstNodeType::AstArrayType:{
            auto array = std::static_pointer_cast<AstArrayType>(type);
            if (!array->size.has_value()){
                throw std::runtime_error("Array without size during code generation.");
            }
            if (array->size.value()->getType() != AstNodeType::AstInteger){
                throw std::runtime_error("Array with non constant size during code generation.");
            }
            return sizeFromSemanticalType(array->subtype) * std::static_pointer_cast<AstInteger>(array->size.value())->value;
        }
        default: throw std::runtime_error("Unimplemented type used");
    }
}

std::string NASMCodeGenerator::generate(){
    sources.fill("");
    indentLevels.fill(0);

    externalLabels = {"memset", "memcpy"};

    VariableSizeInserter sizeInserter(root);
    sizeInserter.insert(NASMCodeGenerator::sizeFromSemanticalType);

    root->accept(this);

    std::string output = "";
    output += "; NASM code generated by R-Sharp compiler";
    output += "\n\nBITS 64\n";
    output += "section .text\n";

    for (std::string const& externalLabel : externalLabels){
        output += "extern " + externalLabel + "\n";
    }

    output += sources.at(static_cast<int>(BinarySection::Text));
    output += "\nsection .data\n";
    output += sources.at(static_cast<int>(BinarySection::Data));
    output += "\nsection .bss\n";
    output += sources.at(static_cast<int>(BinarySection::BSS));



    return output;
}

void NASMCodeGenerator::emitSyscall(Syscall callNr, std::string const& arg1, std::string const& arg2, std::string const& arg3, std::string const& arg4, std::string const& arg5, std::string const& arg6){
    // move the arguments to rdi, rsi, rdx, r10, r8, and r9 respectively
    emitIndented("; Syscall " + syscallToString(callNr) + "(" + std::to_string(static_cast<int>(callNr)) + ")\n");
    if (arg1 != "") emitIndented("mov rdi, " + arg1 + "\n");
    if (arg2 != "") emitIndented("mov rsi, " + arg2 + "\n");
    if (arg3 != "") emitIndented("mov rdx, " + arg3 + "\n");
    if (arg4 != "") emitIndented("mov r10, " + arg4 + "\n");
    if (arg5 != "") emitIndented("mov r8, " + arg5 + "\n");
    if (arg6 != "") emitIndented("mov r9, " + arg6 + "\n");

    emitIndented("mov rax, " + std::to_string(static_cast<int>(callNr)) + "\n");

    emitIndented("syscall\n");
}

std::string NASMCodeGenerator::getUniqueLabel(std::string const& prefix){
    static uint64_t labelCounter = 0;
    return prefix + "_" + std::to_string(labelCounter++);
}
void NASMCodeGenerator::generateFunctionProlouge(){
    emitIndented("; Create stack frame\n");

    // save callee-saved registers
    emitIndented("push rbx\n");
    emitIndented("push rbp\n");
    emitIndented("push r12\n");
    emitIndented("push r13\n");
    emitIndented("push r14\n");
    emitIndented("push r15\n");
    emitIndented("mov rbp, rsp\n");
}

void NASMCodeGenerator::generateFunctionEpilouge(){
    emitIndented("; Destroy stack frame\n");
    
    // restore callee-saved registers
    emitIndented("pop r15\n");
    emitIndented("pop r14\n");
    emitIndented("pop r13\n");
    emitIndented("pop r12\n");
    emitIndented("pop rbp\n");
    emitIndented("pop rbx\n");
}
void NASMCodeGenerator::setupLocalVariables(std::shared_ptr<AstBlock> scope){
    emitIndented("; allocate local variables\n");
    emitIndented("sub rsp, " + std::to_string(scope->sizeOfLocalVariables) + "\n");
    int max_name_length = 0;
    for (auto var : scope->variables){
        max_name_length = std::max<int>(max_name_length, var->name.length());
    }
    max_name_length += 4;
    for (auto var : scope->variables){
        emitIndented("; " + var->name);
        for (int i=0; i<max_name_length - var->name.length(); i++) emit(" ");
        emit(std::to_string(std::get<int>(var->accessor)) + "\n");
    }
}
void NASMCodeGenerator::resetStackPointer(std::shared_ptr<AstBlock> scope){
    emitIndented("; Restore stack pointer to before this scope (" + scope->name + ")\n");
    emitIndented("add rsp, " + std::to_string(scope->sizeOfLocalVariables) + "\n");
}

std::string NASMCodeGenerator::sizeToNASMType(int size){
    if (size == 8) return "qword";
    else if (size == 4) return "dword";
    else if (size == 2) return "word";
    else if (size == 1) return "byte";
    else{
        Fatal("Invalid size ", size);
        return "";
    }
}

std::string NASMCodeGenerator::getRegisterWithSize(std::string reg, int size){
    const std::map<std::pair<std::string, int>, std::string> map = {
        {{"rax", 1}, "al"},
        {{"rax", 2}, "ax"},
        {{"rax", 4}, "eax"},
        {{"rax", 8}, "rax"},

        {{"rbx", 1}, "bl"},
        {{"rbx", 2}, "bx"},
        {{"rbx", 4}, "ebx"},
        {{"rbx", 8}, "rbx"},

        {{"rcx", 1}, "cl"},
        {{"rcx", 2}, "cx"},
        {{"rcx", 4}, "ecx"},
        {{"rcx", 8}, "rcx"},

        {{"rdx", 1}, "dl"},
        {{"rdx", 2}, "dx"},
        {{"rdx", 4}, "edx"},
        {{"rdx", 8}, "rdx"},

        {{"rsi", 1}, "sil"},
        {{"rsi", 2}, "si"},
        {{"rsi", 4}, "esi"},
        {{"rsi", 8}, "rsi"},

        {{"rdi", 1}, "dil"},
        {{"rdi", 2}, "di"},
        {{"rdi", 4}, "edi"},
        {{"rdi", 8}, "rdi"},

        {{"rsp", 1}, "spl"},
        {{"rsp", 2}, "sp"},
        {{"rsp", 4}, "esp"},
        {{"rsp", 8}, "rsp"},

        {{"rbp", 1}, "bpl"},
        {{"rbp", 2}, "bp"},
        {{"rbp", 4}, "ebp"},
        {{"rbp", 8}, "rbp"},

        {{"r0", 1}, "r0b"},
        {{"r0", 2}, "r0w"},
        {{"r0", 4}, "r0d"},
        {{"r0", 8}, "r0"},


        {{"r1", 1}, "r1b"},
        {{"r1", 2}, "r1w"},
        {{"r1", 4}, "r1d"},
        {{"r1", 8}, "r1"},


        {{"r2", 1}, "r2b"},
        {{"r2", 2}, "r2w"},
        {{"r2", 4}, "r2d"},
        {{"r2", 8}, "r2"},


        {{"r3", 1}, "r3b"},
        {{"r3", 2}, "r3w"},
        {{"r3", 4}, "r3d"},
        {{"r3", 8}, "r3"},


        {{"r4", 1}, "r4b"},
        {{"r4", 2}, "r4w"},
        {{"r4", 4}, "r4d"},
        {{"r4", 8}, "r4"},


        {{"r5", 1}, "r5b"},
        {{"r5", 2}, "r5w"},
        {{"r5", 4}, "r5d"},
        {{"r5", 8}, "r5"},


        {{"r6", 1}, "r6b"},
        {{"r6", 2}, "r6w"},
        {{"r6", 4}, "r6d"},
        {{"r6", 8}, "r6"},


        {{"r7", 1}, "r7b"},
        {{"r7", 2}, "r7w"},
        {{"r7", 4}, "r7d"},
        {{"r7", 8}, "r7"},


        {{"r8", 1}, "r8b"},
        {{"r8", 2}, "r8w"},
        {{"r8", 4}, "r8d"},
        {{"r8", 8}, "r8"},


        {{"r9", 1}, "r9b"},
        {{"r9", 2}, "r9w"},
        {{"r9", 4}, "r9d"},
        {{"r9", 8}, "r9"},


        {{"r10", 1}, "r10b"},
        {{"r10", 2}, "r10w"},
        {{"r10", 4}, "r10d"},
        {{"r10", 8}, "r10"},


        {{"r11", 1}, "r11b"},
        {{"r11", 2}, "r11w"},
        {{"r11", 4}, "r11d"},
        {{"r11", 8}, "r11"},


        {{"r12", 1}, "r12b"},
        {{"r12", 2}, "r12w"},
        {{"r12", 4}, "r12d"},
        {{"r12", 8}, "r12"},


        {{"r13", 1}, "r13b"},
        {{"r13", 2}, "r13w"},
        {{"r13", 4}, "r13d"},
        {{"r13", 8}, "r13"},


        {{"r14", 1}, "r14b"},
        {{"r14", 2}, "r14w"},
        {{"r14", 4}, "r14d"},
        {{"r14", 8}, "r14"},


        {{"r15", 1}, "r15b"},
        {{"r15", 2}, "r15w"},
        {{"r15", 4}, "r15d"},
        {{"r15", 8}, "r15"},
    };

    return map.at({reg, size});
}

// program
void NASMCodeGenerator::visit(std::shared_ptr<AstProgram> node){
    node->globalScope->accept(this);
    
    for (auto var : node->globalScope->variables){
        var->accessor = getUniqueLabel(var->name);
    }

    for (auto const& child : node->getChildren()){
        if (!child) continue;
        if (child->getType() == AstNodeType::AstFunctionDefinition){
            child->accept(this);
        }
        else if (child->getType() == AstNodeType::AstVariableDeclaration){
            child->accept(this);
        }
        else{
            Fatal("Invalid node type in program");
        }
    }

    // uninitialized global variables
    for (auto var : node->uninitializedGlobalVariables){
        emitIndented(std::get<std::string>(var->accessor) + ":\n", BinarySection::BSS);
        indent(BinarySection::BSS);
        emitIndented("resb " + std::to_string(var->sizeInBytes) + "\n", BinarySection::BSS);
        dedent(BinarySection::BSS);
    }
}
void NASMCodeGenerator::visit(std::shared_ptr<AstParameterList> node){
    // generate access strings
    node->parameterBlock->accept(this);

    int argumentNumber = 0;
    for (auto  child : node->parameters){
        child->accept(this);

        emitIndented("; Load argument " + std::to_string(argumentNumber) + "\n");

        std::string reg;

        switch(argumentNumber){
            case 0: reg = "rdi"; break;
            case 1: reg = "rsi"; break;
            case 2: reg = "rdx"; break;
            case 3: reg = "rcx"; break;
            case 4: reg = "r8"; break;
            case 5: reg = "r9"; break;
        }
        emitIndented("mov " + sizeToNASMType(child->variable->sizeInBytes) + " [rbp -" + std::to_string(std::get<int>(child->variable->accessor)) + "], " + getRegisterWithSize(reg, child->variable->sizeInBytes) + "\n");
    

        argumentNumber++;
    }
}

// definitions
void NASMCodeGenerator::visit(std::shared_ptr<AstFunctionDefinition> node){
    if(std::find(node->tags->tags.begin(), node->tags->tags.end(), AstTags::Value::Extern) == node->tags->tags.end()){
        emitIndented("; Function " + node->name + "\n\n");
        emitIndented("global " + node->functionData->name + "\n");
        emitIndented(node->functionData->name + ":\n");
        indent();
        generateFunctionProlouge();

        node->parameters->accept(this);
        node->body->accept(this);

        emitIndented("; fallback if the function has no return\n");
        generateFunctionEpilouge();
        emitIndented("mov rax, 0\n");
        emitIndented("ret\n");
        dedent();
    }
    else{
        externalLabels.insert(node->functionData->name);
    }
}

// statements
void NASMCodeGenerator::visit(std::shared_ptr<AstBlock> node){
    emitIndented("; Block begin (" + node->name + ")\n");
    indent();

    if (!node->isMerged) setupLocalVariables(node);

    for (auto child : node->getChildren()){
        if (child) child->accept(this);
    }

    // don't change stack pointer if it wasn't modified
    if (!node->isMerged) resetStackPointer(node);
    dedent();
    emitIndented("; Block end (" + node->name + ")\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstReturn> node){
    node->value->accept(this);
    for (auto scope = node->containedScopes.rbegin(); scope != node->containedScopes.rend(); ++scope){
        if (scope->expired()){
            Fatal("INTERNAL ERROR: std::weak_ptr expired during code generation.");
        }
        else{
            resetStackPointer(scope->lock());
        }
    }
    generateFunctionEpilouge();
    emitIndented("ret\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstConditionalStatement> node){
    std::string else_label = "." + getUniqueLabel("else");
    std::string end_label = "." + getUniqueLabel("end");

    node->condition->accept(this);
    emitIndented("; If statement\n");
    emitIndented("cmp rax, 0\n");
    emitIndented("je " + else_label + "\n");
    indent();
    node->trueStatement->accept(this);
    emitIndented("jmp " + end_label + "\n");
    dedent();
    emitIndented(else_label + ":\n");
    indent();
    if (node->falseStatement) node->falseStatement->accept(this);
    dedent();
    emitIndented(end_label + ":\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstForLoopDeclaration> node){
    std::string start_label = "." + getUniqueLabel("start");
    std::string end_label = "." + getUniqueLabel("end");
    std::string increment_label = "." + getUniqueLabel("increment");

    node->loop->skipAccessString = increment_label;
    node->loop->breakAccessString = end_label;

    emitIndented("; For loop\n");
    emitIndented("; For loop initialization\n");
    setupLocalVariables(node->initializationContext);
    node->initialization->accept(this);

    emitIndented(start_label + ":\n");
    indent();
    emitIndented("; For loop condition\n");
    node->condition->accept(this);
    emitIndented("cmp rax, 0\n");
    emitIndented("je " + end_label + "\n");

    emitIndented("; For loop body\n");
    node->body->accept(this);
    dedent();
    emitIndented("; For loop increment\n");
    emitIndented(increment_label + ":\n");
    indent();
    node->increment->accept(this);
    emitIndented("jmp " + start_label + "\n");
    dedent();
    emitIndented(end_label + ":\n");

    // manually restore the stack pointer
    resetStackPointer(node->initializationContext);
    emitIndented("; For loop end\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstForLoopExpression> node){
    std::string start_label = "." + getUniqueLabel("start");
    std::string end_label = "." + getUniqueLabel("end");
    std::string increment_label = "." + getUniqueLabel("increment");

    node->loop->skipAccessString = increment_label;
    node->loop->breakAccessString = end_label;

    emitIndented("; For loop\n");
    emitIndented("; For loop initialization\n");
    node->variable->accept(this);

    emitIndented("; For loop\n");
    emitIndented(start_label + ":\n");
    indent();
    emitIndented("; For loop condition\n");
    node->condition->accept(this);
    emitIndented("cmp rax, 0\n");
    emitIndented("je " + end_label + "\n");

    emitIndented("; For loop body\n");
    node->body->accept(this);
    dedent();
    emitIndented("; For loop increment\n");
    emitIndented(increment_label + ":\n");
    indent();
    node->increment->accept(this);
    emitIndented("jmp " + start_label + "\n");

    dedent();
    emitIndented(end_label + ":\n");
    emitIndented("; For loop end\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstWhileLoop> node){
    std::string start_label = "." + getUniqueLabel("start");
    std::string end_label = "." + getUniqueLabel("end");

    node->loop->skipAccessString = start_label;
    node->loop->breakAccessString = end_label;

    emitIndented("; While loop\n");
    emitIndented(start_label + ":\n");
    indent();
    node->condition->accept(this);
    emitIndented("cmp rax, 0\n");
    emitIndented("je " + end_label + "\n");
    emitIndented("; Body\n");
    node->body->accept(this);
    emitIndented("jmp " + start_label + "\n");
    dedent();
    emitIndented(end_label + ":\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstDoWhileLoop> node){
    std::string start_label = "." + getUniqueLabel("start");
    std::string end_label = "." + getUniqueLabel("end");

    node->loop->skipAccessString = start_label;
    node->loop->breakAccessString = end_label;

    emitIndented("; Do loop\n");
    emitIndented(start_label + ":\n");
    indent();
    emitIndented("; Body\n");
    node->body->accept(this);
    node->condition->accept(this);
    emitIndented("cmp rax, 0\n");
    emitIndented("jne " + start_label + "\n");
    dedent();
    emitIndented(end_label + ":\n");

}
void NASMCodeGenerator::visit(std::shared_ptr<AstBreak> node){
    for (auto varScope = node->containedScopes.rbegin(); varScope != node->containedScopes.rend(); ++varScope){
        if (varScope->expired()){
            Fatal("INTERNAL ERROR: std::weak_ptr expired during code generation.");
        }
        else{
            resetStackPointer(varScope->lock());
        }
    }

    emitIndented("; Break\n");
    emitIndented("jmp " + node->loop->breakAccessString + "\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstSkip> node){
    for (auto varScope = node->containedScopes.rbegin(); varScope != node->containedScopes.rend(); ++varScope){
        if (varScope->expired()){
            Fatal("INTERNAL ERROR: std::weak_ptr expired during code generation.");
        }
        else{
            resetStackPointer(varScope->lock());
        }
    }

    emitIndented("; Skip\n");
    emitIndented("jmp " + node->loop->skipAccessString + "\n");
}


// expressions
void NASMCodeGenerator::visit(std::shared_ptr<AstUnary> node){
    node->value->accept(this);
    switch (node->type){
        case AstUnaryType::Negate:
            emitIndented("neg rax\n");
            break;
        case AstUnaryType::BinaryNot:
            emitIndented("not rax\n");
            break;
        case AstUnaryType::LogicalNot:
            emitIndented("cmp rax, 0\n");
            emitIndented("mov rax, 0\n");
            emitIndented("sete al\n");
            break;
        default:
            Error("NASM Generator: Unary operator not implemented!");
            printErrorToken(node->token, R_SharpSource);
            exit(1);
            break;
    }
}
void NASMCodeGenerator::visit(std::shared_ptr<AstBinary> node){
    node->left->accept(this);

    int leftSize = sizeFromSemanticalType(node->left->semanticType);

    // logical and and or will short circuit, so the right side is not evaluated until necessary
    if (!(node->type == AstBinaryType::LogicalAnd || node->type == AstBinaryType::LogicalOr)){
        emitIndented("push rax\n");
        node->right->accept(this);
        emitIndented("mov rbx, rax\n");
        emitIndented("pop rax\n");
    }
    switch (node->type){
        case AstBinaryType::Add:{
            emitIndented("; Add\n");
            if (node->left->semanticType->getType() == AstNodeType::AstPointerType){
                emitIndented("imul rbx, rbx, " + std::to_string(sizeFromSemanticalType(std::static_pointer_cast<AstPointerType>(node->left->semanticType)->subtype)) + "\n");
            }
            else if (node->right->semanticType->getType() == AstNodeType::AstPointerType){
                emitIndented("imul rax, rax, " + std::to_string(sizeFromSemanticalType(std::static_pointer_cast<AstPointerType>(node->right->semanticType)->subtype)) + "\n");
            }
            emitIndented("add rax, rbx\n");
            break;
        }
        case AstBinaryType::Subtract:
            emitIndented("; Subtract\n");
            if (node->left->semanticType->getType() == AstNodeType::AstPointerType){
                emitIndented("imul rbx, rbx, " + std::to_string(sizeFromSemanticalType(node->left->semanticType)) + "\n");
            }
            else if (node->right->semanticType->getType() == AstNodeType::AstPointerType){
                emitIndented("imul rax, rax, " + std::to_string(sizeFromSemanticalType(node->right->semanticType)) + "\n");
            }
            emitIndented("sub rax, rbx\n");
            break;
        case AstBinaryType::Multiply:
            emitIndented("; Multiply\n");
            emitIndented("imul rax, rbx\n");
            break;
        case AstBinaryType::Divide:
            emitIndented("; Divide\n");
            if (sizeFromSemanticalType(node->left->semanticType) == 1)
                emitIndented("cbw    ; sign extend from 8-bit to 16-bit\n");
            if (sizeFromSemanticalType(node->left->semanticType) == 2)
                emitIndented("cwd    ; sign extend from 16-bit to 32-bit\n");
            if (sizeFromSemanticalType(node->left->semanticType) == 4)
                emitIndented("cdq    ; sign extend from 32-bit to 64-bit\n");
            if (sizeFromSemanticalType(node->left->semanticType) == 8)
                emitIndented("cqo    ; sign extend from 64-bit to 128-bit\n");

            emitIndented("idiv " + getRegisterWithSize("rbx", sizeFromSemanticalType(node->left->semanticType)) + "\n");
            break;
        case AstBinaryType::Modulo:
            emitIndented("; Modulo\n");
            if (sizeFromSemanticalType(node->left->semanticType) == 1)
                emitIndented("cbw    ; sign extend from 8-bit to 16-bit\n");
            if (sizeFromSemanticalType(node->left->semanticType) == 2)
                emitIndented("cwd    ; sign extend from 16-bit to 32-bit\n");
            if (sizeFromSemanticalType(node->left->semanticType) == 4)
                emitIndented("cdq    ; sign extend from 32-bit to 64-bit\n");
            if (sizeFromSemanticalType(node->left->semanticType) == 8)
                emitIndented("cqo    ; sign extend from 64-bit to 128-bit\n");

            emitIndented("idiv " + getRegisterWithSize("rbx", sizeFromSemanticalType(node->left->semanticType)) + "\n");
            emitIndented("mov rax, rdx\n");
            break;

        case AstBinaryType::Equal:
            emitIndented("; Equal\n");
            emitIndented("cmp " + getRegisterWithSize("rax", leftSize) + ", " + getRegisterWithSize("rbx", leftSize) + "\n");
            emitIndented("sete al\n");
            emitIndented("movzx eax, al\n");
            break;
        case AstBinaryType::NotEqual:
            emitIndented("; Not Equal\n");
            emitIndented("cmp " + getRegisterWithSize("rax", leftSize) + ", " + getRegisterWithSize("rbx", leftSize) + "\n");
            emitIndented("setne al\n");
            emitIndented("movzx eax, al\n");
            break;
        case AstBinaryType::LessThan:
            emitIndented("; Less Than\n");
            emitIndented("cmp " + getRegisterWithSize("rax", leftSize) + ", " + getRegisterWithSize("rbx", leftSize) + "\n");
            emitIndented("setl al\n");
            emitIndented("movzx eax, al\n");
            break;
        case AstBinaryType::LessThanOrEqual:
            emitIndented("; Less Than Or Equal\n");
            emitIndented("cmp " + getRegisterWithSize("rax", leftSize) + ", " + getRegisterWithSize("rbx", leftSize) + "\n");
            emitIndented("setle al\n");
            emitIndented("movzx eax, al\n");
            break;
        case AstBinaryType::GreaterThan:
            emitIndented("; Greater Than\n");
            emitIndented("cmp " + getRegisterWithSize("rax", leftSize) + ", " + getRegisterWithSize("rbx", leftSize) + "\n");
            emitIndented("setg al\n");
            emitIndented("movzx eax, al\n");
            break;
        case AstBinaryType::GreaterThanOrEqual:
            emitIndented("; Greater Than Or Equal\n");
            emitIndented("cmp " + getRegisterWithSize("rax", leftSize) + ", " + getRegisterWithSize("rbx", leftSize) + "\n");
            emitIndented("setge al\n");
            emitIndented("movzx eax, al\n");
            break;

        case AstBinaryType::LogicalAnd:{
            emitIndented("; Logical And\n");
            std::string clause2 = "." + getUniqueLabel("second_expression");
            std::string end = "." + getUniqueLabel("end");
            emitIndented("cmp rax, 0\n");
            emitIndented("jne " + clause2 + "\n");
            emitIndented("jmp " + end + "\n");
            emitIndented(clause2 + ":\n"); indent();

            // evaluate right side
            node->right->accept(this);
            emitIndented("cmp rax, 0\n");
            emitIndented("mov rax, 0\n");
            emitIndented("setne al\n");
            dedent();
            emitIndented(end + ":\n");
            break;
        }

        case AstBinaryType::LogicalOr:{
            emitIndented("; Logical Or\n");
            std::string clause2 = "." + getUniqueLabel("second_expression");
            std::string end = "." + getUniqueLabel("end");
            emitIndented("cmp rax, 0\n");
            emitIndented("je " + clause2 + "\n");
            emitIndented("mov rax, 1\n");
            emitIndented("jmp " + end + "\n");
            emitIndented(clause2 + ":\n"); indent();

            // evaluate right side
            node->right->accept(this);
            emitIndented("cmp rax, 0\n");
            emitIndented("mov rax, 0\n");
            emitIndented("setne al\n");
            dedent();
            emitIndented(end + ":\n");
            break;
        }
        default:
            Error("NASM Generator: Binary operator not implemented!");
            printErrorToken(node->token, R_SharpSource);
            exit(1);
            break;
    }
}
void NASMCodeGenerator::visit(std::shared_ptr<AstInteger> node){
    emitIndented("; Integer " + std::to_string(node->value) + "\n");
    emitIndented("mov rax, " + std::to_string(node->value) + "\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstAssignment> node){
    node->rvalue->accept(this);
    if (node->lvalue->getType() == AstNodeType::AstVariableAccess){
        auto var = std::static_pointer_cast<AstVariableAccess>(node->lvalue);
        emitIndented("; Variable assignment (" + var->name + ")\n");
        if (var->variable->isGlobal){
            emitIndented("mov " + sizeToNASMType(var->variable->sizeInBytes) + " [" + std::get<std::string>(var->variable->accessor) + "], " + getRegisterWithSize("rax", var->variable->sizeInBytes) + "\n");
        }
        else{
            emitIndented("mov " + sizeToNASMType(var->variable->sizeInBytes) + " [rbp - " + std::to_string(std::get<int>(var->variable->accessor)) + "], " + getRegisterWithSize("rax", var->variable->sizeInBytes) + "\n");
        }
    }
    else if(node->lvalue->getType() == AstNodeType::AstDereference){
        auto deref = std::static_pointer_cast<AstDereference>(node->lvalue);
        auto size = sizeFromSemanticalType(deref->semanticType);
        emitIndented("; Dereference Assignment\n");
        emitIndented("push rax\n");

        // put the address to store to into rax
        deref->operand->accept(this);

        emitIndented("mov rbx, rax\n");
        emitIndented("pop rax\n");
        emitIndented("mov " + sizeToNASMType(size) + " [rbx], " + getRegisterWithSize("rax", size) + "\n");
    }
    else{
        Error("Unimplemented type of lvalue.");
        printErrorToken(node->lvalue->token, R_SharpSource);
        exit(1);
    }
}
void NASMCodeGenerator::visit(std::shared_ptr<AstConditionalExpression> node){
    std::string true_clause = "." + getUniqueLabel("true_expression");
    std::string false_clause = "." + getUniqueLabel("false_expression");
    std::string end = "." + getUniqueLabel("end");
    node->condition->accept(this);
    emitIndented("; Conditional Expression\n");
    emitIndented("cmp rax, 0\n");
    emitIndented("je " + false_clause + "\n");
    emitIndented(true_clause + ":\n"); indent();
    node->trueExpression->accept(this);
    emitIndented("jmp " + end + "\n");
    dedent();
    emitIndented(false_clause + ":\n"); indent();
    node->falseExpression->accept(this);
    dedent();
    emitIndented(end + ":\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstEmptyExpression> node){
    emitIndented("; Empty Expression\n");
    emitIndented("mov rax, 1\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstExpressionStatement> node){
    stackPassedValueSize = 0;
    node->expression->accept(this);
    if (node->expression->semanticType->getType() == AstNodeType::AstArrayType){
        emitIndented("; Cleanup after array expression\n");
        emitIndented("add rsp, " + std::to_string(stackPassedValueSize) + "\n");
    }
}

void NASMCodeGenerator::functionCallPrologue(){
    emitIndented("; Align to 16 bytes\n");
    emitIndented("mov r12, rsp\n");
    emitIndented("sub rsp, 16\n");
    emitIndented("and rsp, -16\n");
    emitIndented("sub r12, rsp\n");
}
void NASMCodeGenerator::functionCallEpilogue(){
    emitIndented("; Reset stack alignment\n");
    emitIndented("add rsp, r12\n");
}

void NASMCodeGenerator::visit(std::shared_ptr<AstFunctionCall> node){
    // rdi, rsi, rdx, rcx, r8, and r9 are used for parameters
    // more than 6 parameters are not supported yet

    if (node->arguments.size() > 6){
        Error("NASM Generator: More than 6 parameters are not supported yet!");
        printErrorToken(node->token, R_SharpSource);
        exit(1);
    }
    // save registers
    emitIndented("; Prepare for function call (" + node->name + ")\n");
    int argCount = node->arguments.size();
    for (int i = 0; i < argCount; i++){
        switch(i){
            case 0: emitIndented("push rdi\n"); break;
            case 1: emitIndented("push rsi\n"); break;
            case 2: emitIndented("push rdx\n"); break;
            case 3: emitIndented("push rcx\n"); break;
            case 4: emitIndented("push r8\n"); break;
            case 5: emitIndented("push r9\n"); break;
        }
    }

    // evaluate arguments
    for (auto arg : node->arguments){
        arg->accept(this);
        emitIndented("push rax\n");
    }
    // move arguments to registers
    for (int i = argCount - 1; i >= 0; i--){
        switch(i){
            case 0: emitIndented("pop rdi\n"); break;
            case 1: emitIndented("pop rsi\n"); break;
            case 2: emitIndented("pop rdx\n"); break;
            case 3: emitIndented("pop rcx\n"); break;
            case 4: emitIndented("pop r8\n"); break;
            case 5: emitIndented("pop r9\n"); break;
        }
    }

    functionCallPrologue();
    emitIndented("; Function Call (" + node->name + ")\n");
    emitIndented("call " + node->function->name + "\n");
    functionCallEpilogue();

    emitIndented("; Restore after function call (" + node->name + ")\n");
    // restore registers
    for (int i = argCount - 1; i >= 0; i--){
        switch(i){
            case 0: emitIndented("pop rdi\n"); break;
            case 1: emitIndented("pop rsi\n"); break;
            case 2: emitIndented("pop rdx\n"); break;
            case 3: emitIndented("pop rcx\n"); break;
            case 4: emitIndented("pop r8\n"); break;
            case 5: emitIndented("pop r9\n"); break;
        }
    }
}
void NASMCodeGenerator::visit(std::shared_ptr<AstAddressOf> node){
    auto opVariable = std::dynamic_pointer_cast<AstVariableAccess>(node->operand);
    if (opVariable->variable->isGlobal)
        emitIndented("lea rax, [" + std::get<std::string>(opVariable->variable->accessor) + "]\n");
    else
        emitIndented("lea rax, [rbp - " + std::to_string(std::get<int>(opVariable->variable->accessor)) + "]\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstTypeConversion> node){
    int originSize = sizeFromSemanticalType(node->value->semanticType);
    int targetSize = sizeFromSemanticalType(node->semanticType);
    node->value->accept(this);
    if (targetSize > originSize){
        emitIndented("; Convert from " + std::to_string(originSize) + " bytes to " + std::to_string(targetSize) + " bytes.\n");
        emitIndented("movsx ");
        emit(getRegisterWithSize("rax", targetSize) + ", ");
        emit(getRegisterWithSize("rax", originSize) + "\n");
    }
    else if (targetSize == originSize);
    else{
        emitIndented("; explicit and to detect invalid upcasts later (" + std::to_string(originSize) + " Bytes --> " + std::to_string(targetSize) + " Bytes)\n");
        emitIndented("mov rbx, " + std::to_string(uint64_t((__uint128_t(1) << __uint128_t(targetSize*8))-1)) + "\n");
        emitIndented("and rax, rbx\n");
    }
}


void NASMCodeGenerator::visit(std::shared_ptr<AstVariableAccess> node){
    auto size = sizeFromSemanticalType(node->semanticType);
    emitIndented("; Variable Access(" + node->name + ")\n");

    if (node->semanticType->getType() == AstNodeType::AstArrayType){
        emitIndented("; Copy " + std::to_string(size) + " bytes of stack space\n");
        emitIndented("sub rsp, " + std::to_string(size) + "\n");
        emitIndented("mov rdi, rsp\n");
        if (node->variable->isGlobal)
            emitIndented("lea rsi, [" + std::get<std::string>(node->variable->accessor) + "]\n");
        else
            emitIndented("lea rsi, [rbp - " + std::to_string(std::get<int>(node->variable->accessor)) + "]\n");
        emitIndented("mov rdx, " + std::to_string(size) + "\n");
        functionCallPrologue();
        emitIndented("call memcpy\n");
        functionCallEpilogue();
    }

    else{
        if (size != 8 && size != 4){
            // non 32-bit and 64-bit operations don't clear the remaining bits
            emitIndented("xor eax, eax\n");
        }
        if (node->variable->isGlobal)
            emitIndented("mov " + sizeToNASMType(size) + " " + getRegisterWithSize("rax", size) + ", [" + std::get<std::string>(node->variable->accessor) + "]\n");
        else
            emitIndented("mov " + sizeToNASMType(size) + " " + getRegisterWithSize("rax", size) + ", [rbp - " + std::to_string(std::get<int>(node->variable->accessor)) + "]\n");
    }
}
void NASMCodeGenerator::visit(std::shared_ptr<AstDereference> node){
    node->operand->accept(this);
    auto size = NASMCodeGenerator::sizeFromSemanticalType(node->semanticType);
    emitIndented("; Dereference\n");
    emitIndented("mov " + sizeToNASMType(size) + " " + getRegisterWithSize("rax", size) + ", [rax]\n");
    int targetSize = sizeFromSemanticalType(node->semanticType);
    emitIndented("; explicit and to detect invalid upcasts later (8 Bytes --> " + std::to_string(targetSize) + " Bytes)\n");
    emitIndented("mov rbx, " + std::to_string(uint64_t((__uint128_t(1) << __uint128_t(targetSize*8))-1)) + "\n");
    emitIndented("and rax, rbx\n");
}
void NASMCodeGenerator::visit(std::shared_ptr<AstArrayAccess> node){
    stackPassedValueSize = 0;
    emitIndented("; array access\n");
    if (node->array->getType() == AstNodeType::AstDereference){
        std::dynamic_pointer_cast<AstDereference>(node->array)->operand->accept(this);
    }
    else if (node->array->getType() == AstNodeType::AstVariableAccess){
        auto casted = std::dynamic_pointer_cast<AstVariableAccess>(node->array);
        if (casted->variable->isGlobal){
            emitIndented("lea rax, [" + std::get<std::string>(casted->variable->accessor) + "]\n");
        }
        else{
            emitIndented("lea rax, [rbp-" + std::to_string(std::get<int>(casted->variable->accessor)) + "]\n");
        }
    }
    else if (node->array->getType() == AstNodeType::AstArrayLiteral){
        node->array->accept(this);

        emitIndented("mov rax, rsp\n");
    }
    else if (node->array->getType() == AstNodeType::AstArrayAccess){
        node->array->accept(this);

        emitIndented("mov rax, rsp\n");
    }
    else{
        Error("Unimplemented array access\n");
    }

    // rax is the beginning of the array
    int targetSize = sizeFromSemanticalType(node->semanticType);
    emitIndented("push rax\n");
    node->index->accept(this);
    emitIndented("pop rbx\n");
    // rbx: beginning of array, rax: index

    const int oldStackPassedValueSize = stackPassedValueSize;

    switch(targetSize){
        case 1:
        case 2:
        case 4:
        case 8:
            emitIndented("mov " + sizeToNASMType(targetSize) + " " + getRegisterWithSize("rax", targetSize) + ", [rbx+rax*" + std::to_string(targetSize) + "]\n");
            stackPassedValueSize = 0;
            break;
        default:{
            /*
            Stack:
                --------------------------
                | Array that got indexed |  size: oldStackPassedValueSize
            rbx --------------------------
            rsp
            */
            emitIndented("\n");
            emitIndented("; Copy " + std::to_string(targetSize) + " bytes of stack space\n");
            emitIndented("mov rcx, " + std::to_string(targetSize) + "\n");
            emitIndented("mul rcx\n");
            emitIndented("add rax, rbx\n");
            emitIndented("mov rsi, rax\n");
            emitIndented("sub rsp, " + std::to_string(targetSize) + "\n");
            /*
            Stack:
                --------------------------
            rsi | Array that got indexed |  size: oldStackPassedValueSize
            rbx --------------------------
                | Resulting thing (empty)|  size: targetSize
                --------------------------
            rsp
            */
            emitIndented("mov rdi, rsp\n");
            emitIndented("mov rdx, " + std::to_string(targetSize) + "\n");
            /*
            Stack:
                --------------------------
            rsi | Array that got indexed |  size: oldStackPassedValueSize
            rbx --------------------------
                | Resulting thing (empty)|  size: targetSize
            rdi --------------------------
            rsp
            */
            functionCallPrologue();
            emitIndented("call memcpy\n");
            functionCallEpilogue();
            stackPassedValueSize = sizeFromSemanticalType(node->semanticType);
            break;
        }
    }

    // cleanup
    if (node->array->getType() == AstNodeType::AstArrayLiteral || node->array->getType() == AstNodeType::AstArrayAccess){
        /*
        Stack:
            --------------------------
            | Array that got indexed |  size: oldStackPassedValueSize
            --------------------------
            | Resulting thing        |  size: stackPassedValueSize
            --------------------------
        -->

        we need to memcpy the thing over the array and then free the unused stack space
        */
        emitIndented("\n");
        emitIndented("; Cleanup after array access\n");
        emitIndented("; Copy " + std::to_string(stackPassedValueSize) + " bytes of stack space\n");
        emitIndented("lea rdi, [rsp+" + std::to_string(oldStackPassedValueSize) + "]\n"); //
        emitIndented("mov rsi, rsp\n");
        emitIndented("mov rdx, " + std::to_string(stackPassedValueSize) + "\n");
        emitIndented("mov rbx, rax\n");
        functionCallPrologue();
        emitIndented("call memcpy\n");
        functionCallEpilogue();
        emitIndented("mov rax, rbx\n");

        emitIndented("add rsp, " + std::to_string(oldStackPassedValueSize) + "\n");
    }
}
void NASMCodeGenerator::visit(std::shared_ptr<AstArrayLiteral> node) {
    uint64_t elementSize = sizeFromSemanticalType(std::dynamic_pointer_cast<AstArrayType>(node->semanticType)->subtype);
    emitIndented("\n");
    emitIndented("; Array Literal\n");
    emitIndented("sub rsp, " + std::to_string(sizeFromSemanticalType(node->semanticType)) + "\n");
    uint64_t currentOffset = 0;
    for (auto element : node->elements){
        element->accept(this);
        switch(elementSize){
            case 1:
            case 2:
            case 4:
            case 8:
                emitIndented("mov " + sizeToNASMType(elementSize) + " [rsp+" + std::to_string(currentOffset) + "], " + getRegisterWithSize("rax", elementSize) + "\n");
                break;
            default:{
                emitIndented("; Copy " + std::to_string(elementSize) + " bytes of stack space\n");
                emitIndented("lea rdi, [rsp+" + std::to_string(currentOffset+elementSize) + "]\n");
                emitIndented("mov rsi, rsp\n");
                emitIndented("mov rdx, " + std::to_string(elementSize) + "\n");
                functionCallPrologue();
                emitIndented("call memcpy\n");
                functionCallEpilogue();
                break;
            }
        }
        currentOffset += elementSize;
        if (element->getType() == AstNodeType::AstArrayLiteral){
            emitIndented("add rsp, " + std::to_string(stackPassedValueSize) + "\n");
        }
    }

    stackPassedValueSize = sizeFromSemanticalType(node->semanticType);
}

void NASMCodeGenerator::defineGlobalData(std::shared_ptr<AstExpression> node){
    if (node->getType() == AstNodeType::AstInteger){
        auto intNode = std::dynamic_pointer_cast<AstInteger>(node);
        switch(sizeFromSemanticalType(node->semanticType)){
            case 1: emitIndented("db " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            case 2: emitIndented("dw " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            case 4: emitIndented("dd " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            case 8: emitIndented("dq " + std::to_string(intNode->value) + "\n", BinarySection::Data); break;
            default:
                Error("NASM Generator: Global variable size not supported!");
                printErrorToken(node->token, R_SharpSource);
                exit(1);
                break;
        }
    }
    else if (node->getType() == AstNodeType::AstArrayLiteral){
        auto arrayNode = std::dynamic_pointer_cast<AstArrayLiteral>(node);
        for (auto element : arrayNode->elements){
            bool contains_array = element->semanticType->getType() == AstNodeType::AstArrayType;
            if (contains_array)
                indent(BinarySection::Data);

            defineGlobalData(element);
            if (contains_array){
                dedent(BinarySection::Data);
                emitIndented("\n", BinarySection::Data);
            }
        }
    }
    else{
        Error("NASM Generator: Global variable must be an integer or array. (Found: " + node->toString() + ")");
        printErrorToken(node->token, R_SharpSource);
        exit(1);
    }
}

// declarations
void NASMCodeGenerator::visit(std::shared_ptr<AstVariableDeclaration> node){
    if (node->variable->isGlobal){
        if (!node->value){
            return;
        }
        emitIndented("; Global Variable (" + node->name + ")\n", BinarySection::Data);
        emitIndented("global " + std::get<std::string>(node->variable->accessor) + "\n", BinarySection::Data);
        emitIndented(std::get<std::string>(node->variable->accessor) + ":\n", BinarySection::Data);
        indent(BinarySection::Data);
        defineGlobalData(node->value);
        dedent(BinarySection::Data);
    }
    else{
        emitIndented("; Variable (" + node->name + ")\n");
        if (node->variable->type.lock()->getType() == AstNodeType::AstArrayType){
            if (node->value){
                node->value->accept(this);
                auto size = node->variable->sizeInBytes;
                emitIndented("; Copy " + std::to_string(size) + " bytes of stack space\n");
                emitIndented("mov rsi, rsp\n");
                if (node->variable->isGlobal)
                    emitIndented("lea rdi, [" + std::get<std::string>(node->variable->accessor) + "]\n");
                else
                    emitIndented("lea rdi, [rbp - " + std::to_string(std::get<int>(node->variable->accessor)) + "]\n");
                emitIndented("mov rdx, " + std::to_string(size) + "\n");
                functionCallPrologue();
                emitIndented("call memcpy\n");
                functionCallEpilogue();
                emitIndented("add rsp, " + std::to_string(size) + "\n");
            }
            else{
                auto size = sizeFromSemanticalType(node->semanticType);
                emitIndented("; Zero out " + std::to_string(size) + " bytes of stack space\n");
                emitIndented("lea rdi, [rbp-" + std::to_string(std::get<int>(node->variable->accessor)) + "]\n");
                emitIndented("mov rsi, 0\n");
                emitIndented("mov rdx, " + std::to_string(size) + "\n");
                functionCallPrologue();
                emitIndented("call memset\n");
                functionCallEpilogue();
            }
        }

        else{
            switch (node->variable->sizeInBytes){
                case 1:
                case 2:
                case 4:
                case 8:
                    if (node->value){
                        node->value->accept(this);
                        emitIndented("mov [rbp - " + std::to_string(std::get<int>(node->variable->accessor)) + "], " + getRegisterWithSize("rax", node->variable->sizeInBytes) + "\n");
                    }
                    else{
                        emitIndented("mov " + sizeToNASMType(node->variable->sizeInBytes) + " [rbp - " + std::to_string(std::get<int>(node->variable->accessor)) + "], 0\n");
                    }
                    break;
                
                default:
                    Error("NASM Generator: Unsupported variable size " + std::to_string(node->variable->sizeInBytes) + " for variable '" + node->variable->name + "'");
                    printErrorToken(node->token, R_SharpSource);
                    exit(1);
            }
        }
    }
}