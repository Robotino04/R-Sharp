#include "R-Sharp/NASMCodeGenerator.hpp"
#include "R-Sharp/Logging.hpp"
#include "R-Sharp/AstNodes.hpp"

NASMCodeGenerator::NASMCodeGenerator(std::shared_ptr<AstNode> root){
    this->root = root;
}

void NASMCodeGenerator::indent(){
    indentLevel++;
}
void NASMCodeGenerator::dedent(){
    if (!indentLevel){
        Error("Indentation error");
        return;
    }
    indentLevel--;
}
void NASMCodeGenerator::emit(std::string const& str){
    source += str;
}
void NASMCodeGenerator::emitIndented(std::string const& str){
    for (int i=0;i<indentLevel;i++){
        source += "    ";
    }
    source += str;
}

std::string NASMCodeGenerator::generate(){
    source = "";
    indentLevel = 0;
    labelCounter = 0;
    root->accept(this);
    return source;
}

void NASMCodeGenerator::emitSyscall(Syscall callNr, std::string const& arg1, std::string const& arg2, std::string const& arg3, std::string const& arg4, std::string const& arg5, std::string const& arg6){
    // move the arguments to rdi, rsi, rdx, r10, r8, and r9 respectively
    emitIndented("; Syscall " + std::to_string(callNr) + "(" + std::to_string(static_cast<int>(callNr)) + ")\n");
    if (arg1 != "") emitIndented("mov rdi, " + arg1 + "\n");
    if (arg2 != "") emitIndented("mov rsi, " + arg2 + "\n");
    if (arg3 != "") emitIndented("mov rdx, " + arg3 + "\n");
    if (arg4 != "") emitIndented("mov r10, " + arg4 + "\n");
    if (arg5 != "") emitIndented("mov r8, " + arg5 + "\n");
    if (arg6 != "") emitIndented("mov r9, " + arg6 + "\n");

    emitIndented("mov rax, " + std::to_string(static_cast<int>(callNr)) + "\n");

    emitIndented("syscall\n");
}

std::string NASMCodeGenerator::getUniqueLabel(){
    return "label" + std::to_string(labelCounter++);
}

// program
void NASMCodeGenerator::visit(AstProgram* node){
    emit("; NASM code generated by R-Sharp compiler");
    emit("\n\nBITS 64\n");
    emit("global _start\n");
    emit("section .text\n");
    for (auto const& child : node->getChildren()){
        if (child->getType() == AstNodeType::AstFunction){
            child->accept(this);
        }
        else{
            Error("NASM Generator: Only functions are implemented!");
        }
    }
    emit("_start:\n");
    indent();
    emit("call main\n");
    emitSyscall(Syscall::exit, "rax");
    dedent();
}

// definitions
void NASMCodeGenerator::visit(AstFunction* node){
    emit("; Function " + node->name + "\n");
    emit("\n");
    emit("global " + node->name + "\n");
    emit(node->name + ":\n");
    indent();
    for (auto const& child : node->getChildren()){
        child->accept(this);
    }
    dedent();
}


// statements
void NASMCodeGenerator::visit(AstReturn* node){
    node->value->accept(this);
    emitIndented("ret\n");
}


// expressions
void NASMCodeGenerator::visit(AstUnary* node){
    node->value->accept(this);
    switch (node->type){
        case AstUnaryType::Negate:
            emitIndented("neg rax\n");
            break;
        case AstUnaryType::BinaryNot:
            emitIndented("not rax\n");
            break;
        case AstUnaryType::LogicalNot:
            emitIndented("cmp rax, 0\n");
            emitIndented("mov rax, 0\n");
            emitIndented("sete al\n");
        default:
            Error("NASM Generator: Unary operator not implemented!");
    }
}
void NASMCodeGenerator::visit(AstBinary* node){
    node->left->accept(this);

    // logical and and or will short circuit, so the right side is not evaluated until necessary
    if (!(node->type == AstBinaryType::LogicalAnd || node->type == AstBinaryType::LogicalOr)){
        emitIndented("push rax\n");
        node->right->accept(this);
        emitIndented("mov rbx, rax\n");
        emitIndented("pop rax\n");
    }
    switch (node->type){
        case AstBinaryType::Add:
            emitIndented("; Add\n");
            emitIndented("add rax, rbx\n");
            break;
        case AstBinaryType::Subtract:
            emitIndented("; Subtract\n");
            emitIndented("sub rax, rbx\n");
            break;
        case AstBinaryType::Multiply:
            emitIndented("; Multiply\n");
            emitIndented("imul rax, rbx\n");
            break;
        case AstBinaryType::Divide:
            emitIndented("; Divide\n");
            emitIndented("cqo\n");
            emitIndented("idiv rbx\n");
            break;
        case AstBinaryType::Modulo:
            emitIndented("; Modulo\n");
            emitIndented("cqo\n");
            emitIndented("idiv rbx\n");
            emitIndented("mov rax, rdx\n");
            break;

        case AstBinaryType::Equal:
            emitIndented("; Equal\n");
            emitIndented("cmp rax, rbx\n");
            emitIndented("mov rax, 0\n");
            emitIndented("sete al\n");
            break;
        case AstBinaryType::NotEqual:
            emitIndented("; Not Equal\n");
            emitIndented("cmp rax, rbx\n");
            emitIndented("mov rax, 0\n");
            emitIndented("setne al\n");
            break;
        case AstBinaryType::LessThan:
            emitIndented("; Less Than\n");
            emitIndented("cmp rax, rbx\n");
            emitIndented("mov rax, 0\n");
            emitIndented("setl al\n");
            break;
        case AstBinaryType::LessThanOrEqual:
            emitIndented("; Less Than Or Equal\n");
            emitIndented("cmp rax, rbx\n");
            emitIndented("mov rax, 0\n");
            emitIndented("setle al\n");
            break;
        case AstBinaryType::GreaterThan:
            emitIndented("; Greater Than\n");
            emitIndented("cmp rax, rbx\n");
            emitIndented("mov rax, 0\n");
            emitIndented("setg al\n");
            break;
        case AstBinaryType::GreaterThanOrEqual:
            emitIndented("; Greater Than Or Equal\n");
            emitIndented("cmp rax, rbx\n");
            emitIndented("mov rax, 0\n");
            emitIndented("setge al\n");
            break;

        case AstBinaryType::LogicalAnd:{
            emitIndented("; Logical And\n");
            std::string clause2 = getUniqueLabel();
            std::string end = getUniqueLabel();
            emitIndented("cmp rax, 0\n");
            emitIndented("jne " + clause2 + "\n");
            emitIndented("jmp " + end + "\n");
            emitIndented(clause2 + ":\n"); indent();

            // evaluate right side
            node->right->accept(this);
            emitIndented("cmp rax, 0\n");
            emitIndented("mov rax, 0\n");
            emitIndented("setne al\n");
            dedent();
            emitIndented(end + ":\n");
            break;
        }

        case AstBinaryType::LogicalOr:{
            emitIndented("; Logical Or\n");
            std::string clause2 = getUniqueLabel();
            std::string end = getUniqueLabel();
            emitIndented("cmp rax, 0\n");
            emitIndented("je " + clause2 + "\n");
            emitIndented("mov rax, 1\n");
            emitIndented("jmp " + end + "\n");
            emitIndented(clause2 + ":\n"); indent();

            // evaluate right side
            node->right->accept(this);
            emitIndented("cmp rax, 0\n");
            emitIndented("mov rax, 0\n");
            emitIndented("setne al\n");
            dedent();
            emitIndented(end + ":\n");
            break;
        }
        default:
            Error("NASM Generator: Binary operator not implemented!");
    }
}
void NASMCodeGenerator::visit(AstInteger* node){
    emitIndented("mov rax, " + std::to_string(node->value) + "\n");
}